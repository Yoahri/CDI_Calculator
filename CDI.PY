# -- coding: utf-8 --
"""Untitled8.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16uwot5ufUZkTJ7Vp1cOFzXNIzmak5QHc
"""

import pandas as pd
import matplotlib.pyplot as plt
import requests
from bs4 import BeautifulSoup
import requests
import holidays
from datetime import datetime

# Função para obter as taxas Selic a partir da api do site do Governo Federal
def get_selic_rates():
    url = 'https://www.bcb.gov.br/api/servico/sitebcb/historicotaxasjuros'
    response = requests.get(url)
    data = response.json()
    df = pd.DataFrame(data)
    df['DataInicioVigencia'] = df['conteudo'].apply(lambda x: x.get('DataInicioVigencia', None))
    df['DataFimVigencia'] = df['conteudo'].apply(lambda x: x.get('DataFimVigencia', None))
    df['MetaSelic'] = df['conteudo'].apply(lambda x: x.get('MetaSelic', None))
    df['DataInicioVigencia'] = pd.to_datetime(df['DataInicioVigencia'], format='%Y-%m-%dT%H:%M:%SZ', utc=True)
    df['DataFimVigencia'] = pd.to_datetime(df['DataFimVigencia'], format='%Y-%m-%dT%H:%M:%SZ', utc=True)

    df_resultado = df[['DataInicioVigencia', 'DataFimVigencia', 'MetaSelic']]

    return df_resultado

    
# Função para calcular dias úteis com feriados brasileiros entre duas datas
def networkdays_brazil(start_date, end_date):
    # Obter os feriados brasileiros entre as datas de início e fim
    brazil_holidays = holidays.Brazil(years=list(range(start_date.year, end_date.year + 1)))

    # Gerar datas úteis entre as datas de início e fim
    all_days = pd.date_range(start=start_date, end=end_date, freq='B', tz='America/Sao_Paulo')

    # Filtrar feriados brasileiros
    business_days = [day for day in all_days if day not in brazil_holidays]



    return (len(business_days),business_days)


def get_pre_bmf():
    url = 'https://www2.bmf.com.br/pages/portal/bmfbovespa/boletim1/txref1.asp'

    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')

    # Encontrar todas as tabelas na página
    tabelas = soup.find_all('table')

    # Verificar se há pelo menos duas tabelas na página
    if len(tabelas) >= 2:
        # Extrair os dados da segunda tabela
        dados_html = tabelas[1].select('td')

        # Extrair o texto e substituir ',' por '.'
        dados_texto = [td.get_text().replace(',', '.') for td in dados_html]

        # Dividir os dados em três colunas (considerando que o cabeçalho está correto)
        colunas = [dados_texto[i:i + 3] for i in range(0, len(dados_texto), 3)]

        # Criar um DataFrame com as colunas apropriadas
        dados_df = pd.DataFrame(colunas, columns=['Dias Corridos', 'DI x pré1', 'DI x pré2'])

        # Remover a linha 1
        dados_df = dados_df.iloc[1:]

        # Reorganizar os dados conforme necessário
        dados_df['Dias Corridos'], dados_df['DI x pré1'], dados_df['DI x pré2'] = dados_df['DI x pré1'], dados_df['DI x pré2'], dados_df['Dias Corridos']

        # Remover \r e \n das colunas 'DI x pré1' e 'DI x pré2'
        dados_df['DI x pré1'] = dados_df['DI x pré1'].str.replace('\r', '').str.replace('\n', '')
        dados_df['DI x pré2'] = dados_df['DI x pré2'].str.replace('\r', '').str.replace('\n', '')

        # Converter as colunas para float
        colunas_numericas = ['Dias Corridos', 'DI x pré1', 'DI x pré2']
        dados_df[colunas_numericas] = dados_df[colunas_numericas].apply(pd.to_numeric, errors='coerce')

        # Renomear os cabeçalhos
        dados_df.columns = ['DI x pré2','Dias Corridos', 'DI x pré1']
        dados_df['Dias Corridos'] = dados_df['Dias Corridos'].shift(1)
        dados_df.loc[0, 'Dias Corridos'] = 0.0

        return dados_df
    else:
        print("Não há pelo menos duas tabelas na página.")
        return None
def cdi_calculator(start_date, end_date,value):
    #Inicialização dos dados requisitados
    diaatual=pd.to_datetime(datetime.now().date())
    diasiniciofim=networkdays_brazil(diaatual, end_date)[0]
    calendario=networkdays_brazil(start_date,diaatual)[1]
    df=get_selic_rates()
    prebmf=get_pre_bmf()
    df['DataFimVigencia'].fillna(diaatual.tz_localize('UTC'), inplace=True)
    df['DataInicioVigencia'] = pd.to_datetime(df['DataInicioVigencia']).dt.date
    df['DataFimVigencia'] = pd.to_datetime(df['DataFimVigencia']).dt.date
   
    valoracruado=value
   
    t=1
    juros=1
    valordadivida=[]#Valor inical com os juros
    jurosaotempo=[]#juros ao longo do tempo
    tempo=[]
    contador=0
    for day in calendario:
        filtro = (df['DataInicioVigencia'] <= day.date()) & (df['DataFimVigencia'].isnull() | (day.date() <= df['DataFimVigencia']))
        metaselic_filtrada = float(df.loc[filtro]['MetaSelic'])
        juros *=((1+(metaselic_filtrada/100))**(t/252))
        tempo.append(contador)
        contador+=1
        tamanho=valoracruado*juros
        jurosaotempo.append(juros)
        valordadivida.append(tamanho)
    valor_mais_proximo = prebmf['Dias Corridos'].iloc[(prebmf['Dias Corridos'] - diasiniciofim).abs().idxmin()]
    # Filtrar o DataFrame para a linha associada ao valor mais próximo
    linha_associada = prebmf[prebmf['Dias Corridos'] == valor_mais_proximo]

    # Obter o valor correspondente de 'DI x pré1'
    valor_di_x_pre1 = linha_associada['DI x pré1'].iloc[0]
    valordadivida.append(value*juros*(1+valor_di_x_pre1/100)**(valor_mais_proximo/252))
    jurosaotempo.append((1+valor_di_x_pre1/100)**(valor_mais_proximo/252))
    tempo.append(tempo[-1]+valor_mais_proximo)
    df_plot = pd.DataFrame({'Tempo (dias úteis)': tempo, 'Juros ao Longo do Tempo': jurosaotempo, 'Valor da Dívida ao Longo do Tempo': valordadivida})
   
 

    # Plot the graph of time x interest factor
    plt.figure(figsize=(10, 6))
    plt.plot(tempo, jurosaotempo, label='Juros ao Longo do Tempo', color='blue')
    plt.title('Juros ao Longo do Tempo')
    plt.xlabel('Tempo (dias úteis)')
    plt.ylabel('Fator de Juros')
    plt.legend()
    plt.grid(True)
    plt.savefig('juros_grafico.png')  # Save the plot as an image

    # Plot the graph of time x debt value
    plt.figure(figsize=(10, 6))
    plt.plot(tempo, valordadivida, label='Valor da Dívida ao Longo do Tempo', color='green')
    plt.title('Valor da Dívida ao Longo do Tempo')
    plt.xlabel('Tempo (dias úteis)')
    plt.ylabel('Valor da Dívida')
    plt.legend()
    plt.grid(True)
    plt.savefig('divida_grafico.png')  # Save the plot as an image

    with pd.ExcelWriter('relatorio.xlsx', engine='xlsxwriter') as writer:
        df_plot.to_excel(writer, sheet_name='Plots Data', index=False)

        # Get the xlsxwriter workbook and worksheet objects
        workbook = writer.book
        worksheet = writer.sheets['Plots Data']

        # Get the dimensions of the dataframe
        num_rows, num_cols = df_plot.shape

        # Create a list of column headers, to use in add_table()
        column_settings = [{'header': col, 'header_format': workbook.add_format({'bold': True, 'bg_color': '#FFA07A'})} for col in df_plot.columns]

        # Add the Excel table structure. Pandas will add the data
        worksheet.add_table(0, 0, num_rows, num_cols - 1, {'columns': column_settings})

        # Create a new DataFrame for start and end dates and final values
        final_values_df = pd.DataFrame({
            'Data de Início': [str(start_date)],
            'Data de Fim': [str(end_date)],
            'Juros Final': [df_plot['Juros ao Longo do Tempo'].iloc[-1]],
            'Valor Final': [df_plot['Valor da Dívida ao Longo do Tempo'].iloc[-1]],
            'Lucro Final': [float(df_plot['Valor da Dívida ao Longo do Tempo'].iloc[-1])-value]
        })

        # Save the new DataFrame to a new sheet in the Excel file
        final_values_df.to_excel(writer, sheet_name='Final Values', index=False)

        # Plot the final interest and debt values only in the second table
        worksheet = writer.sheets['Final Values']

        # Get the dimensions of the new dataframe
        num_rows, num_cols = final_values_df.shape
        column_settings = [{'header': col, 'header_format': workbook.add_format({'bold': True, 'bg_color': '#FFA07A'})} for col in final_values_df.columns]
        worksheet.add_table(0, 0, num_rows, num_cols - 1, {'columns': column_settings})

def main():
    while True:
        start_date_input = input("Enter the start date (YYYY-MM-DD): ")
        end_date_input = input("Enter the end date (YYYY-MM-DD): ")
        value_input = input("Enter the initial value: ")

        try:
            # Convert input strings to datetime objects and validate the initial value
            start_date = pd.to_datetime(start_date_input).date()
            end_date = pd.to_datetime(end_date_input).date()
            value = float(value_input)

            if value > 0:
                break
            else:
                print("Please enter a value greater than zero for the initial value.")
        except ValueError:
            print("Invalid input. Please enter valid dates and a numerical value for the initial value.")


    # Call the cdi_calculator function with user inputs
    cdi_calculator(start_date, end_date, value)

if __name__ == "__main__":
    # Call the main function
    main()